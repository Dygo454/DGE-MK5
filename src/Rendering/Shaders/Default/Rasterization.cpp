#include"../DefaultShaders.h"

// can be changed in how it is compiled
#ifndef MAX_RASTER_DEPTH
#define MAX_RASTER_DEPTH "10"
#endif

namespace Shaders {
    std::string getRasterization() {
        return "#include<limits.h>\n"
        "unsigned char isInTri(double x, double y, double* tri, double* depth = 0, double* u = 0, double* v = 0) {\n"
        "    double Area = 0.5 *(-tri[4]*tri[6] + tri[1]*(-tri[3] + tri[6]) + tri[0]*(tri[4] - tri[7]) + tri[3]*tri[7]);\n"
        "    if (Area < 0.01) return 0;\n"
        "    double s = 1/(2*Area)*(tri[1]*tri[6] - tri[0]*tri[7] + (tri[7] - tri[1])*x + (tri[0] - tri[6])*y);\n"
        "    double t = 1/(2*Area)*(tri[0]*tri[4] - tri[1]*tri[3] + (tri[1] - tri[4])*x + (tri[3] - tri[0])*y);\n"
        "    if (s<0 || t<0 || (1-s-t)<0) return 0;\n"
        "    if (depth) {\n"
        "        *depth = s * tri[5] + t * tri[8] + (1 - s - t) * tri[0];\n"
        "    }\n"
        "    if (u) *u = s;"
        "    if (v) *v = s;"
        "    return 1;\n"
        "}\n"
        "\n"
        "void swap(double* d1, double* d2) {\n"
        "    *d1 = (*d1)^(*d2);\n"
        "    *d2 = (*d1)^(*d2);\n"
        "    *d1 = (*d1)^(*d2);\n"
        "}\n"
        "\n"
        "void swap(unsigned int* i1, unsigned int* i2) {\n"
        "    *i1 = (*i1)^(*i2);\n"
        "    *i2 = (*i1)^(*i2);\n"
        "    *i1 = (*i1)^(*i2);\n"
        "}\n"
        "\n"
        "int min(int i1, int i2) {\n"
        "    return i1<=i2 ? i1 : i2;\n"
        "}\n"
        "\n"
        "kernel void Rasterization(void* assembled, void* fragmentsBuffer, unsigned int width, unsigned int height, unsigned char rasterMode) {\n"
        "    unsigned int x = get_global_id(0);\n"
        "    unsigned int y = get_global_id(1);\n"
        "    if (x >= width) return;\n"
        "    if (y >= height) return;\n"
        "    int maxDepth = " MAX_RASTER_DEPTH ";\n"
        "    int currMaxDepth = 0;\n"
        "    int ind = x + (y*width);\n"
        "    size_t fragSize = sizeof(double)*3+sizeof(unsigned int)\n"
        "    void* fragBufferOffset = fragmentsBuffer + (fragSize*maxDepth*ind);\n"
        "    for (unsigned int i = 0; i < assembled[0]; ++i) {\n"
        "        double* assembledOffset = assembled + ((i*24*sizeof(double)) + 1);\n"
        "        double depth = 0;\n"
        "        double u_i = 0;\n"
        "        double v_i = 0;\n"
        "        unsigned int otherI = i;\n"
        "        if (rasterMode == 0) {\n" // center of pixel
        "            if (!isInTri(((double)x)+0.5, ((double)y)+0.5, assembledOffset, &depth, &u_i, &v_i))\n" // TODO: u and v need to be in terms of triangle uv also!
        "                continue;\n"
        "        }\n"
        "        else {\n" // TODO: add more modes???
        "            continue;\n"
        "        }\n"
        "        double u = (assembledOffset[20]-assembledOffset[18])*u_i + (assembledOffset[22]-assembledOffset[18])*v_i + assembledOffset[18];\n"
        "        double v = (assembledOffset[21]-assembledOffset[19])*u_i + (assembledOffset[23]-assembledOffset[19])*v_i + assembledOffset[19];\n"
        "        ++currMaxDepth;\n"
        "        int d = 0;\n"
        "        for (; d < min(maxDepth, currMaxDepth-1); ++d)\n"
        "            if (*(double*)(fragBufferOffset+(fragSize*d)) > depth)\n"
        "                break;\n"
        "        for (; d < min(maxDepth, currMaxDepth); ++d) {\n"
        "            swap(&depth, fragBufferOffset+(fragSize*d));\n"
        "            swap(&u, fragBufferOffset+(fragSize*d)+sizeof(double));\n"
        "            swap(&v, fragBufferOffset+(fragSize*d)+sizeof(double)*2);\n"
        "            swap(&otherI, fragBufferOffset+(fragSize*d)+sizeof(double)*3);\n"
        "        }\n"
        "    }\n"
        "}";
    }
}
