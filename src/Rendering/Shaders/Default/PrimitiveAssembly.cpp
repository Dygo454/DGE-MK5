#include"../DefaultShaders.h"

namespace Shaders {
    std::string getPrimitiveAssembly() {
        return "struct CameraSettings {"
        "    unsigned int targetWidth;"
        "    unsigned int targetHeight;"
        "    double nearPlane;"
        "    double farPlane;"
        "    double fovY;"
        "    double sizeY;"
        "    unsigned char rasterStyle;"
        "    bool orthographic;"
        "};"
        "struct vec2 {"
        "    double x;"
        "    double y;"
        "};"
        "float sign (vec2 p1, vec2 p2, vec2 p3) {"
        "    return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);"
        "}"
        "bool pointInTriangle(vec2 pt, vec2 v1, vec2 v2, vec2 v3) {"
        "    float d1, d2, d3;"
        "    bool has_neg, has_pos;"
        "    "
        "    d1 = sign(pt, v1, v2);"
        "    d2 = sign(pt, v2, v3);"
        "    d3 = sign(pt, v3, v1);"
        "    "
        "    has_neg = (d1 < 0) || (d2 < 0) || (d3 < 0);"
        "    has_pos = (d1 > 0) || (d2 > 0) || (d3 > 0);"
        "    "
        "    return !(has_neg && has_pos);"
        "}"
        "void increase(volatile __global int* counter, unsigned int num) {"
        "    atomic_add(counter, num);"
        "}"
        "kernel void PrimitiveAssembly(global void* verticies, global void* assembly, global void* assembled, global unsigned int* pixelBuffer, CameraSettings settings) {"
        "    unsigned int tri = get_global_id(0);"
        "    unsigned int x = get_global_id(1);"
        "    unsigned int y = get_global_id(2);"
        "    unsigned int pixel = (x*settings.targetWidth + y) * 3;"
        "    "
        "    if (x < 0 || x >= settings.targetWidth) return;"
        "    if (y < 0 || y >= settings.targetHeight) return;"
        "    if (tri >= ((unsigned int*)assembly)[0]) return;"
        "    "
        "    ((unsigned int*)assembled)[pixel+1] = 0xFFFFFFFF;"
        "    ((unsigned int*)assembled)[pixel+2] = 0xFFFFFFFF;"
        "    vec2 vtl;"
        "    vtl.x = x;"
        "    vtl.y = y;"
        "    vec2 vtr;"
        "    vtr.x = x+1;"
        "    vtr.y = y;"
        "    vec2 vbl;"
        "    vbl.x = x;"
        "    vbl.y = y+1;"
        "    vec2 vbr;"
        "    vbr.x = x+1;"
        "    vbr.y = y+1;"
        "    vec2 v;"
        "    v.x = x+0.5;"
        "    v.y = y+0.5;"
        "    "
        "    double* vPtr = ((double*)verticies)[((unsigned int*)assembly)[tri+1] * 3 + 4];"
        "    vec2 v1;"
        "    v1.x = vPtr[0];"
        "    v1.y = vPtr[1];"
        "    "
        "    double* vPtr = ((double*)verticies)[((unsigned int*)assembly)[tri+2] * 3 + 4];"
        "    vec2 v2;"
        "    v2.x = vPtr[0];"
        "    v2.y = vPtr[1];"
        "    "
        "    double* vPtr = ((double*)verticies)[((unsigned int*)assembly)[tri+3] * 3 + 4];"
        "    vec2 v3;"
        "    v3.x = vPtr[0];"
        "    v3.y = vPtr[1];"
        "    "
        "    if (x > max(max(v1.x,v2.x),v3.x) || x < min(min(v1.x,v2.x),v3.x)) {"
        "        return;"
        "    }"
        "    if (y > max(max(v1.y,v2.y),v3.y) || y < min(min(v1.y,v2.y),v3.y)) {"
        "        return;"
        "    }"
        "    if (!pointInTriangle(vtl, v1, v2, v3) && !pointInTriangle(vtr, v1, v2, v3) && !pointInTriangle(vbl, v1, v2, v3) && !pointInTriangle(vbr, v1, v2, v3)) {"
        "        return;"
        "    }"
        "    if (!pointInTriangle(v, v1, v2, v3)) {"
        "        return;"
        "    }"
        "    increase((unsigned int*)assembled, 14);"
        "    unsigned int pixelNew = 0;"
        "    for (int i = 0; i < pixelOld; i++) {"
        "        pixelNew += 12 + (14 * ((unsigned int*)assembled)[pixelOld]);"
        "    }"
        "}";
    }
}
