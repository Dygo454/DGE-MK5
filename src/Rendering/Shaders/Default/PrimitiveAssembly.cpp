#include"../DefaultShaders.h"

namespace Shaders {
    std::string getPrimitiveAssembly(cl::CommandQueue* q) {
        return "struct CameraSettings {"
        "    unsigned int targetWidth;"
        "    unsigned int targetHeight;"
        "    double nearPlane;"
        "    double farPlane;"
        "    double fovY;"
        "    double sizeY;"
        "    unsigned char rasterStyle;"
        "    bool orthographic;"
        "};"
        "struct vec2 {"
        "    double x;"
        "    double y;"
        "};"
        "float sign (vec2 p1, vec2 p2, vec2 p3) {"
        "    return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);"
        "}"
        "bool pointInTriangle(vec2 pt, vec2 v1, vec2 v2, vec2 v3) {"
        "    float d1, d2, d3;"
        "    bool has_neg, has_pos;"
        "    "
        "    d1 = sign(pt, v1, v2);"
        "    d2 = sign(pt, v2, v3);"
        "    d3 = sign(pt, v3, v1);"
        "    "
        "    has_neg = (d1 < 0) || (d2 < 0) || (d3 < 0);"
        "    has_pos = (d1 > 0) || (d2 > 0) || (d3 > 0);"
        "    "
        "    return !(has_neg && has_pos);"
        "}"
        "kernel void PrimitiveAssembly(global void* verticies, global void* assembly, global void* assembled, CameraSettings settings) {"
        "    unsigned int tri = get_global_id(0);"
        "    unsigned int x = get_global_id(1);"
        "    unsigned int y = get_global_id(2);"
        "    unsigned int pixel = (x*settings.targetWidth + y) * 3;"
        "    "
        "    if (x < 0 || x >= settings.targetWidth) return;"
        "    if (y < 0 || y >= settings.targetHeight) return;"
        "    if (tri >= ((unsigned int*)assembly)[0]) return;"
        "    "
        "    ((unsigned int*)assembled)[pixel+1] = 0xFFFFFFFF;"
        "    ((unsigned int*)assembled)[pixel+2] = 0xFFFFFFFF;"
        "    vec2 vtl;"
        "    vtl.x = x;"
        "    vtl.y = y;"
        "    vec2 vtr;"
        "    vtr.x = x+1;"
        "    vtr.y = y;"
        "    vec2 vbl;"
        "    vbl.x = x;"
        "    vbl.y = y+1;"
        "    vec2 vbr;"
        "    vbr.x = x+1;"
        "    vbr.y = y+1;"
        "    vec2 v;"
        "    v.x = x+0.5;"
        "    v.y = y+0.5;"
        "    "
        "    double* vPtr = ((double*)verticies)[((unsigned int*)assembly)[tri+1] * 3 + 4];"
        "    vec2 v1;"
        "    v1.x = vPtr[0];"
        "    v1.y = vPtr[1];"
        "    "
        "    double* vPtr = ((double*)verticies)[((unsigned int*)assembly)[tri+2] * 3 + 4];"
        "    vec2 v2;"
        "    v2.x = vPtr[0];"
        "    v2.y = vPtr[1];"
        "    "
        "    double* vPtr = ((double*)verticies)[((unsigned int*)assembly)[tri+3] * 3 + 4];"
        "    vec2 v3;"
        "    v3.x = vPtr[0];"
        "    v3.y = vPtr[1];"
        "    "
        "    if (x > max(max(v1.x,v2.x),v3.x) || x < min(min(v1.x,v2.x),v3.x)) {"
        "        return;"
        "    }"
        "    if (y > max(max(v1.y,v2.y),v3.y) || y < min(min(v1.y,v2.y),v3.y)) {"
        "        return;"
        "    }"
        "    if (!pointInTriangle(vtl, v1, v2, v3) && !pointInTriangle(vtr, v1, v2, v3) && !pointInTriangle(vbl, v1, v2, v3) && !pointInTriangle(vbr, v1, v2, v3)) {"
        "        return;"
        "    }"
        "    if (!pointInTriangle(v, v1, v2, v3)) {"
        "        return;"
        "    }"
        "    atomic_add(((unsigned int*)assembled)[pixel+1], 1);"
        "    atomic_add(((unsigned int*)assembled)[0], 14);"
        "}";
    }
    void doPrimitiveAssembly(cl::Kernel* k, cl::Buffer* vertexBuffer, cl::Buffer* assemblyBuffer, cl::Buffer* textureBuffers, cl::CommandQueue* q, const Rendering::CameraSettings& settings, cl::Buffer** passingBuffer, cl::Buffer* outBuffer) {
        cl::Buffer* assembledBuffer = new cl::Buffer(assemblyBuffer->getInfo<CL_MEM_CONTEXT>(), CL_MEM_READ_WRITE, settings.targetWidth*settings.targetHeight*12 + 4);
        u32 tempSize = settings.targetWidth*settings.targetHeight*12 + 4;
        q->enqueueWriteBuffer(*assembledBuffer, CL_FALSE, 0, 4, &tempSize);
        cl::KernelFunctor primitiveAssembly(*k, *q, cl::NullRange, cl::NDRange((assemblyBuffer->getInfo<CL_MEM_SIZE>()-4)/12, settings.targetWidth, settings.targetHeight), cl::NullRange);
        primitiveAssembly(*vertexBuffer, *assemblyBuffer, *assembledBuffer, settings);
        (*passingBuffer) = assembledBuffer;
        q->finish();
    }
}
